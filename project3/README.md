## Project 3: Advanced SQL Assignment, CMSC424, Spring 2020

*The assignment is to be done by yourself.*

### Setup

As before we have created a VagrantFile for you. The main differences here are that we have loaded a skewed database (`synthetic`), and also installed Java. Start by doing `vagrant up` and `vagrant ssh` as usual. 

### Assignment Questions

**Question 1 (.5 pt)**: Consider the following query written to find the number of Gold Medals won by players whose name starts with 'Chris'. 

```
select p.player_id, p.name, count(r.medal)
from players p join results r on (p.player_id = r.player_id and r.medal = 'GOLD' and p.name like 'Chris%') 
group by p.player_id, p.name
order by p.player_id;
```

The result, however, does not contain the players whose name starts with 'Chris' that have not won a gold medal. So we may consider rewriting it to use a left outer join:

```
select p.player_id, p.name, count(r.medal)
from players p left outer join results r on (p.player_id = r.player_id and r.medal = 'GOLD' and p.name like 'Chris %') 
group by p.player_id, p.name
order by p.player_id;
```

Briefly explain why this query does not return the expected answer (as below), and rewrite the query so that it does. 

The final answer should look like this:
```
 player_id  |                   name                   | count
------------+------------------------------------------+-------
 ARRONCHR01 | Christine Arron                          |     0
 FYDLECHR01 | Chris Fydler                             |     1
 HUFFICHR01 | Chris Huffins                            |     0
 OLSSOCHR01 | Christian Olsson                         |     1
 THOMPCHR01 | Chris Thompson                           |     0
 WILLICHR02 | Chris Williams                           |     0
(6 rows)
```

---
**Question 2 (.5 pt)**: EXPLAIN can be used to see the query plan used by the database system to execute a query. For the following
query, draw the query plan for the query, clearly showing the different operators and the options they take. The query corresponds to question 2 in Project 1.
```
select extract(year from birthdate) as birthyear, count(distinct players.player_id) as num_players, count(case when results.medal = 'GOLD' then 1 end)
from players, results, events
where players.player_id = results.player_id and events.event_id = results.event_id and events.olympic_id = 'ATH2004'
group by extract(year from birthdate)
order by birthyear asc
```

---
**Question 3 (.5 pt)**: Similarly draw the query plan for the following query, and annotate which operators are responsible for creating `temp`, and the final
answer (Question 7 from Project 1).
```
with temp as (
    select p.name as player_name, birthdate, o.olympic_id as olympic_id, startdate, enddate 
    from players p, events e, results r, olympics o 
    where p.player_id = r.player_id and r.event_id = e.event_id and e.olympic_id = o.olympic_id
) 
select distinct player_name, birthdate, olympic_id 
from temp
where extract(year from age(startdate - 1, birthdate)) != extract(year from age(enddate, birthdate))
order by player_name; 
```

---
**Question 4 (.5 pt)**: The EXPLAIN output also shows how many tuples the optimizer expects to be generated after each operation (`rows`). EXPLAIN ANALYZE 
executes the query and also shows the **actual** number of tuples generated when the query plan was executed. 

To see this more clearly, we have populated a second database called `synthetic`, with three relations: R(A, B), S(B, C), and T(C, D). (Use `psql synthetic` to run the queries against it).

For the following two queries, identify some of the key intermediate results that were generated by the database, what were their estimated cardinalities (sizes), and what were their actual cardinalities, using EXPLAIN ANALYZE. Did the database generally do a good job on estimating the sizes of the intermediate results? Can you trace the differences in the actual cardinalities for the two queries (which only differ in one constant) to the properties of the data?
```
Query 1:
select count(*) 
from R, S, T 
where R.B = S.B and S.C = T.C and T.C = 1;
```
```
Query 2:
select count(*) 
from R, S, T 
where R.B = S.B and S.C = T.C and T.C = 48;
```

---
**Question 5 (1 pt)**: [Trigger] 
Let's create a table `MedalCounts(player_id, name, num_medals)` to keep track of the total number of medals for all players (that have at least one medal). Since this is a derived
table (and not a view), it will not be kept up-to-date by the database system.  Use the following command for creating the table:
```
create table if not exists MedalCounts as
    select p.player_id, name, count(*) as num_medals
    from results r, players p
    where r.player_id = p.player_id
    group by p.player_id, name;
```

Write a `trigger` to keep this new table updated when a new entry is inserted into or a row is deleted from the `results` table. Remember the `player_id` corresponding
to the new update to `results` may not exist in the `MedalCounts` table at that time and it should be added to the table with a count of 1, in that case. Similarly, if a
deletion of a row in `results` results in a player not having any medals, then the corresponding tuple for that player in `MedalCounts` should be deleted.

The trigger code should be submitted in `trigger.sql` file, as straight SQL. Running `psql -f trigger.sql olympics` should generate the trigger without errors.

---
**Question 6 (2 pt)**:  One of more prominent ways to use a database system is using an external client, using APIs such as ODBC and JDBC.
This allows you to run queries against the database and access the results from within say a Java program.

Here are some useful links:
- [Wikipedia Article](http://en.wikipedia.org/wiki/Java_Database_Connectivity)
- [Another resource](http://www.mkyong.com/java/how-do-connect-to-postgresql-with-jdbc-driver-java/)
- [PostgreSQL JDBC](http://jdbc.postgresql.org/index.html)

The last link has detailed examples in the `documentation` section. The `project3` directory (in the git repository) also contains an example 
file (`JDBCExample.java`). To run the JDBCExample.java file, do:
`javac JDBCExample.java` followed by `java -classpath .:./postgresql-42.2.10.jar JDBCExample`.

Your task to write a JDBC program **that will take in JSON updates and insert appropriate data into the database.** 
Two types of updates should be supported:
- New `event`, where information about a new event is provided, in the following format. You can assume that the foreign key reference is to one of the two olympics, eventtype is one of "ATH" or "SWI", and all the other fields are valid.
```
{ "newevent": 
	{
	"event_id": "E157",
	"name": "Quadruple Jump Men",
	"eventtype": "ATH",
	"olympic_id": "SYD2000",
    "is_team_event": "0",
    "num_players_in_team": "-1",
    "result_noted_in": "meters"
	}
}

```
- Medal information, where information about the medal recepients is provided. 
```
{ "medalinformation": {
	"event_id": "E157",
	"players_and_medals": [
		{"player_id": "EGBELAAR01", "medal": "GOLD", "result": "100"}, 
		{"player_id": "NELSOADA01", "medal": "SILVER", "result": "99"}, 
		{"player_id": "POPOVALE01", "medal": "BRONZE", "result": "98"}
		]
	}
}
```
You should not assume anything regarding the number of players receiving medals (e.g., the event may be a team event with many medalists).

Your code should also catch two types of error for the second update: If the `event_id` or one of the `player_id`s is not present in the respective tables, an error
should be gracefully printed out, and none of the medals should be added to the `results' table. 


### Parsing JSON
There are quite a few Java JSON parsing libraries out there to simplify the parsing process. To simplify matters, we have provided a JSON parsing library for you to use: `json-simple-1.1.1.jar`. Here is the webpage for the library: https://github.com/fangyidong/json-simple. Some code samples can be found in `src/test` directory there, or you can also see some examples here: https://www.mkyong.com/java/json-simple-example-read-and-write-json/

The provided `JSONProcessing.java` file already takes care of the input part, and you just need to focus on finishing the `processJSON(String json)` function. An example JSON file is provided: `example.json`.

### Submission Instructions
We have provided a `answers.docx` file -- fill in your answers to the first 4 questions into that doc file (including scanned PDFs or images).
You may want to use some tool (e.g., Google Drawing) to draw query plans.
In addition, submit your `trigger.sql` and `JSONProcessing.java` files separately.

We will provide some additional test scripts later.
